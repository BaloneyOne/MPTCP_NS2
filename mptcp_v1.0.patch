diff -ruN ns/ns-2.35/apps/app.cc ns-allinone-2.35/ns-2.35/apps/app.cc
--- ns/ns-2.35/apps/app.cc	1999-03-04 10:21:34.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/apps/app.cc	2018-11-03 06:22:31.013972439 +0800
@@ -128,3 +128,11 @@
 	Tcl& tcl = Tcl::instance();
 	tcl.evalf("%s resume", name_);
 }
+
+void Application::agentCallBack(int sid, int high_acked, int cur_seq, int cwnd, double rtt){
+
+}
+
+void Application::notifyReceive(int pid){
+
+}
diff -ruN ns/ns-2.35/apps/app.h ns-allinone-2.35/ns-2.35/apps/app.h
--- ns/ns-2.35/apps/app.h	1999-09-28 11:46:27.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/apps/app.h	2018-11-03 06:22:17.537745249 +0800
@@ -51,6 +51,10 @@
 	virtual void send(int nbytes);
 	virtual void recv(int nbytes);
 	virtual void resume();
+	virtual void agentCallBack(int sid, int high_acked, int cur_seq, int cwnd, double rtt);
+	virtual void notifyReceive(int pid);
+	//void reportCWND(int subflow_index, int high_acked, int cur_seq, int cwnd);
+	//void reportRTT(int subflow_index, double rtt);
 
 protected:
 	virtual int command(int argc, const char*const* argv);
diff -ruN ns/ns-2.35/apps/mptcp.cc ns-allinone-2.35/ns-2.35/apps/mptcp.cc
--- ns/ns-2.35/apps/mptcp.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/apps/mptcp.cc	2019-01-06 03:26:55.811787331 +0800
@@ -0,0 +1,533 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Daedalus Research
+ *	Group at the University of California Berkeley.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Contributed by the Daedalus Research Group, http://daedalus.cs.berkeley.edu
+ *
+ */
+
+#include "mptcp.h"
+#include "agent.h"
+
+
+static class MptcpClass : public TclClass {
+ public:
+	MptcpClass() : TclClass("Mptcp") {}
+	TclObject* create(int, const char*const*) {
+		return (new Mptcp);
+	}
+} class_application;
+
+
+Mptcp::Mptcp() : enableRecv_(0), enableResume_(0),
+			cur_tcp_(0)	// Jesson Liu, attributes initialization
+{
+	isNumSubflowSet = false;
+	max_tcp_num_ = 4;		// the default value of maximum number of subflows
+//	tcp_ = new Agent*[max_tcp_num_];
+	num_pkts_=10000;		//10K packets (~15MB data) to send by default
+	subinfo_ = new std::vector<struct SubflowInfo*>;
+	length_ = SUB_WND_LEN;
+	sndwin_ = max_tcp_num_*length_;
+	cur_acked_ = 0;
+	max_snd_ = 0;
+	mptcp_id_ = 0;
+	scheduler_ = MINRTT;			//0: default, MinRTT first;
+	last_send_ = 0;				//subflow 0 by default, only used in RoundRobin
+	max_block_counter_ = 40;		// default maximum number of unchosen times in MINRTT scheduler
+	mptcp_pkts_ = new std::vector<short>;
+}
+
+void Mptcp::initialSubflow(){
+
+	// max_tcp_num_ is initialized in 'command' function with parameter 'max_tcp_num_'
+
+	for(int i=0; i<max_tcp_num_; i++){
+
+		struct SubflowInfo* temp_info = new struct SubflowInfo;
+		temp_info->id = i;
+		temp_info->tcp_ = NULL;
+		temp_info->high_acked = 0;
+		temp_info->cur_seq = 0;
+		temp_info->cwnd = 0;
+		temp_info->rtt = 0.0;
+		temp_info->block_counter_ = 0;
+		subinfo_->push_back(temp_info);
+	}
+
+	isNumSubflowSet = true;
+}
+
+/* @author Jesson LIU
+ * IMPORTANT NOTICE:
+ *	the initialization of parameters in MPTCPs require the following order:
+ *		1. set-id,		e.g., $mptcp set-id 0
+ *		2. max_tcp_num_, 	e.g., $mptcp max_tcp_num_ 4
+ *(unavailable)	3. num_pkts_,		e.g., $mptcp num_pkts_ 1000000 (not used, omit it)
+ *		4. attach-tcp, 		e.g., $mptcp attach-tcp $tcp($i)
+ *		5. send,		e.g., $mptcp send 100000
+ *	other optional parameters (not required initializing in orders):
+ *		1. scheduler_,		e.g., $mptcp scheduler_ 1 (optional, here means roundrobin)
+ *		2. max_block_counter_,	e.g., $mptcp max_block_counter_ 20 (valid only in MinRTT scheduler)
+ *		3. length_,		e.g., $mptcp length_ 10 (the receiving window size, which equals max_tcp_num_*length_)
+ */
+
+
+int Mptcp::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+		if (strcmp(argv[1], "start") == 0) {
+			// enableRecv_ only if recv() exists in Tcl
+			tcl.evalf("[%s info class] info instprocs", name_);
+			char result[1024];
+			sprintf(result, " %s ", tcl.result());
+			enableRecv_ = (strstr(result, " recv ") != 0);
+			enableResume_ = (strstr(result, " resume ") != 0);
+			start();
+			return (TCL_OK);
+		}
+		if (strcmp(argv[1], "stop") == 0) {
+			stop();
+			return (TCL_OK);
+		}
+
+		/*if (strcmp(argv[1], "agent") == 0) {
+			tcl.resultf("%s", agent_->name());
+			return (TCL_OK);
+		}*/
+	}
+	else if (argc == 3) {
+		/*if (strcmp(argv[1], "attach-agent") == 0) {
+			agent_ = (Agent*) TclObject::lookup(argv[2]);
+			if (agent_ == 0) {
+				tcl.resultf("no such agent %s", argv[2]);
+				return(TCL_ERROR);
+			}
+			agent_->attachApp(this);
+			return(TCL_OK);
+		}*/	
+
+		// @author Jesson LIU, for setting maximum number of subflows
+		if (strcmp(argv[1], "max_tcp_num_") == 0) {
+
+			max_tcp_num_ = atoi(argv[2]);
+			this->initialSubflow();
+			//printf("subflow num set\n");
+			return (TCL_OK);
+		}
+
+		if (strcmp(argv[1], "length_") == 0) {
+			
+			length_ = atoi(argv[2]);
+			sndwin_ = max_tcp_num_*length_;
+			return (TCL_OK);
+		}
+		
+		if (strcmp(argv[1], "scheduler_") == 0){
+
+			int type = atoi(argv[2]);
+			if(type == MINRTT){
+
+				scheduler_ = MINRTT;
+			}else if(type == ROUNDROBIN){
+	
+				scheduler_ = ROUNDROBIN;
+			}else{
+
+				scheduler_ = MINRTT;
+			}
+			return (TCL_OK);
+		}
+		
+		if (strcmp(argv[1], "max_block_counter_") == 0) {
+			
+			max_block_counter_ = atoi(argv[2]);
+			return (TCL_OK);
+		}
+
+		if (strcmp(argv[1], "num_pkts_") == 0) {
+			//NOT USEFUL
+			num_pkts_ = atoi(argv[2]);
+			initialPkts();
+			return (TCL_OK);
+		}
+
+		if (strcmp(argv[1], "attach-tcp") == 0) {
+		
+			if(isNumSubflowSet){
+			//	printf("start attach tcps\n");
+				if(cur_tcp_<max_tcp_num_){
+	
+					(*subinfo_)[cur_tcp_]->tcp_ = (TcpAgent*) TclObject::lookup(argv[2]);
+					if ((*subinfo_)[cur_tcp_]->tcp_ == 0) {
+		
+						tcl.resultf("no such agent %s", argv[2]);
+						return (TCL_ERROR);
+					}
+					(*subinfo_)[cur_tcp_]->tcp_->attachApp(this);
+					TcpAgent *tt = (TcpAgent*)((*subinfo_)[cur_tcp_]->tcp_);
+
+					tt->setMPTCPID(mptcp_id_);
+					tt->setSubflowNum(max_tcp_num_);
+					tt->setSubflowID(cur_tcp_);
+
+					(*subinfo_)[cur_tcp_]->id = cur_tcp_;
+					cur_tcp_++;
+					return (TCL_OK);
+				}else{
+					return (TCL_ERROR);
+				}
+			}else{
+				printf("need to set the maximum number of subflow first\n");
+				return (TCL_ERROR);
+			}
+		}
+
+		if (strcmp(argv[1], "set-id") == 0) {
+
+			this->mptcp_id_ = atoi(argv[2]);
+			return (TCL_OK);
+		}
+
+		if (strcmp(argv[1], "send") == 0) {
+			send(atoi(argv[2]));
+			return(TCL_OK);
+		}
+	}
+	return (Process::command(argc, argv));
+}
+
+
+void Mptcp::start()
+{
+}
+
+
+void Mptcp::stop()
+{
+}
+
+void Mptcp::subflowSend(int idx, int len){
+
+	if(len<0){
+		
+		printf("error for %d-th subflow to send %d pkts (it is negtive!)\n", idx, len);
+		return;
+	}
+	(*subinfo_)[idx]->tcp_->setPara(max_snd_, len);
+	(*subinfo_)[idx]->tcp_->sendmsg(len*1460);
+	max_snd_ += len;	// update the maximum SEQ that MPTCP sent
+//	printf("%lf: currently MPTCP#-%d has %d pkts sent in total, in this round, %d pkts sent by %d-th subflow (cur_acked_, sndwin_: %d, %d)\n", Scheduler::instance().clock(), mptcp_id_, max_snd_, len, idx, cur_acked_, sndwin_);
+}
+
+int Mptcp::subflowSend(int len){
+
+	int num_pkt_sent = 0;
+	int pkt_left = len;
+	// select MinRTT subflow with spare cwnd
+	if(scheduler_ == MINRTT){
+
+		bool isSent[max_tcp_num_];
+		for(int i=0; i<max_tcp_num_; i++){
+			isSent[i] = false;
+		}
+		
+		int no_win_counter = 0;
+		while (pkt_left && no_win_counter < max_tcp_num_){
+
+			int sentCounter = 0;
+			double s_rtt = 100000;
+			int s_idx = 0;
+
+			int bc_idx = -1;
+			short m_bt = 0;
+
+			for(int i=0; i<max_tcp_num_; i++){
+				
+				if(!isSent[i]){
+					// pick up smallest RTT subflow among unsent flows
+					double c_rtt = (*subinfo_)[i]->rtt;
+//					printf("@%lf: rtt:%lf, %d-th subflow\n", Scheduler::instance().clock(), c_rtt, i);
+					if(c_rtt<s_rtt){
+						
+						s_rtt = c_rtt;
+						s_idx = i;
+					}
+
+					short t_bt = (*subinfo_)[i]->block_counter_;
+					if(t_bt > max_block_counter_){
+						if(t_bt>m_bt){
+							// record the id of subflow with maximum block counter	
+							bc_idx = i;
+							m_bt = t_bt;
+						}
+					}
+				}else{
+				
+					sentCounter++;
+				}
+			}
+
+			if(sentCounter == max_tcp_num_){
+				// all the subflow have sent data
+				break;
+			}
+
+			if(bc_idx>=0){
+				// there is at least a subflow being block for over max_block_counter_ times
+				// send it this time for preventing starvation and probing current network status
+				s_idx = bc_idx;
+			}
+
+			isSent[s_idx] = true;
+
+			int cwnd = (*subinfo_)[s_idx]->high_acked+(*subinfo_)[s_idx]->cwnd
+					-(*subinfo_)[s_idx]->cur_seq;
+			int pkt_sent_per_round = cwnd < 0 ? 0 : cwnd;
+
+			/*if(pkt_sent_per_round>10){
+				double now = Scheduler::instance().clock();
+				double first = (*subinfo_)[0]->rtt;
+				double second = (*subinfo_)[1]->rtt;
+//				printf("@%lf: [0-1]->%lf-%lf, %d-th is chosen for %d pkts\n", now, first, second, s_idx, pkt_sent_per_round);
+				
+			}*/
+			if((*subinfo_)[s_idx]->block_counter_ > max_block_counter_){
+				// Probe bandwidth and RTT for the slow (in history) subflows
+				pkt_sent_per_round = pkt_sent_per_round>2 ? 2 : pkt_sent_per_round;
+//				printf("%lf: send under permit %d-th: %d\n", Scheduler::instance().clock(), s_idx, pkt_sent_per_round);
+			}
+//			printf("cwnd-capable is %d for %d-th subflow\n", pkt_sent_per_round, s_idx);
+			
+			(*subinfo_)[s_idx]->block_counter_ = 0;
+
+			if(pkt_sent_per_round==0){
+				// there is no room for sending data in current subflow, skip it
+				no_win_counter++;
+				continue;
+			}
+			
+			//printf("rest cwnd of %d-th subflow: %d\n", i, pkt_sent_per_round);
+			
+			if(pkt_left>pkt_sent_per_round){
+
+				subflowSend(s_idx, pkt_sent_per_round);
+				num_pkt_sent += pkt_sent_per_round;
+				pkt_left -= pkt_sent_per_round;
+			}else{
+				
+				subflowSend(s_idx, pkt_left);
+				num_pkt_sent += pkt_left;
+				pkt_left -= pkt_left;
+			}		
+	
+		}
+
+		if(num_pkt_sent > 0) {
+			// decay the RTT
+			for(int i=0; i<max_tcp_num_; i++){
+				
+				if(!isSent[i]){
+					
+//					printf("decay rtt from %lf to %lf for %d-th subflow\n", before, after, i);
+					(*subinfo_)[i]->block_counter_ = (*subinfo_)[i]->block_counter_ + 1;
+				}
+			}
+		}
+
+
+	}else if(scheduler_ == ROUNDROBIN){
+
+		int temp_ls = last_send_;
+
+		while(pkt_left){
+
+			int cwnd = (*subinfo_)[last_send_]->high_acked+(*subinfo_)[last_send_]->cwnd
+					-(*subinfo_)[last_send_]->cur_seq;
+			int pkt_sent_per_round = cwnd < 0 ? 0 : cwnd;
+	
+			// if there is no room for sending data in current subflow, skip it
+			if(pkt_sent_per_round>0){
+//				printf("rest cwnd of %d-th subflow: %d\n", i, pkt_sent_per_round);	
+				int idx = last_send_;
+				
+				if(pkt_left>pkt_sent_per_round){
+					subflowSend(idx, pkt_sent_per_round);
+					num_pkt_sent += pkt_sent_per_round;
+					pkt_left -= pkt_sent_per_round;
+				}else{
+				
+					subflowSend(idx, pkt_left);
+					num_pkt_sent += pkt_left;
+					pkt_left -= pkt_left;
+				}
+			}
+			// move to next subflow
+			last_send_ = (last_send_+1) == max_tcp_num_ ? 0 : (last_send_+1);		
+			if(last_send_==temp_ls){
+				// one round, wait for next time
+				break;
+			}
+		}
+	}else{
+
+		printf("Wrong scheduler!\n");
+	}
+
+	return num_pkt_sent;
+}
+
+void Mptcp::send(int nbytes)
+{
+//	agent_->sendmsg(nbytes);
+	num_pkts_ = nbytes/1460;
+	int num_pkt_left = num_pkts_<sndwin_ ? num_pkts_ : sndwin_;
+
+//	printf("pkts to send in 1st round: %d\n", num_pkt_left);
+
+	initialPkts();			// initial the MPTCP pkts
+
+	// dispatch batches of pkts to different subflows
+	while(num_pkt_left>0){
+
+		for(int i=0; i<max_tcp_num_; i++){
+			// each subflow sends length_ pkts by turn;
+			if(num_pkt_left > length_){
+
+				subflowSend(i, length_);
+				num_pkt_left -= length_;
+			}else{
+
+				subflowSend(i, num_pkt_left);
+				num_pkt_left -= num_pkt_left;
+				// no data left, quit this loop
+	//			printf("pkts left: %d\n", num_pkt_left);
+				break;
+			}
+	
+		}
+	}
+
+//	subinfo_->tcp_->setPara(start, len);
+}
+
+/*
+ * @author Jesson Liu, for initialization of sending window
+ * 0: not acked; 1: acked
+ */
+void Mptcp::initialPkts(){
+
+	for(int i=0; i<num_pkts_; i++){
+
+		mptcp_pkts_->push_back(0);
+	}
+}
+
+void Mptcp::recv(int nbytes)
+{
+	if (! enableRecv_)
+		return;
+	Tcl& tcl = Tcl::instance();
+	tcl.evalf("%s recv %d", name_, nbytes);
+}
+
+
+void Mptcp::resume()
+{
+	if (! enableResume_)
+		return;
+	Tcl& tcl = Tcl::instance();
+	tcl.evalf("%s resume", name_);
+}
+
+void Mptcp::agentCallBack(int sub_id, int high_acked, int cur_seq, int cwnd, double rtt) {
+	// update the information of subflows
+	if(sub_id<max_tcp_num_ && sub_id>=0){
+
+//		printf("%d-th subflow reports: h-ack:%d, cur_seq:%d, cwnd:%d, rtt:%lf\n", sub_id, high_acked, cur_seq, cwnd, rtt);
+		(*subinfo_)[sub_id]->high_acked = high_acked;
+		(*subinfo_)[sub_id]->cur_seq = cur_seq;
+		(*subinfo_)[sub_id]->cwnd = cwnd;
+		(*subinfo_)[sub_id]->rtt = rtt;
+	}else{
+		
+		printf("update subflow (subflow id: %d) information error!\n", sub_id);
+		return;
+	}
+
+}
+
+void Mptcp::notifyReceive(int pid){
+	
+	if(pid<0){
+		// the 0-th data packet is not received yet, cannot deliver more data to TCPs
+		return;
+	}
+
+	// not only the 'pid'-th packet received, but the pkts before it also received
+	if(pid<=(num_pkts_-1)){
+
+		(*mptcp_pkts_)[pid] = 1;
+		for(int i=0; i<pid; i++){
+			if(!(*mptcp_pkts_)[i]){
+				
+				(*mptcp_pkts_)[i] = 1;
+//				printf("%d-th MPTCP finds a miss DATA_ACK: %d\n", mptcp_id_, i);
+			}
+		}
+		updateSndWnd();
+	}else{
+		printf("Wrong pkt num! total:[0-%d], current:%d\n", num_pkts_-1, pid);
+	}
+}
+
+void Mptcp::updateSndWnd(){
+	//update the left edge of MPTCP sending window
+	while((*mptcp_pkts_)[cur_acked_+1]){
+
+		cur_acked_++;
+	}
+	sndwin_ = max_tcp_num_*length_;
+	// Check if there are more data to send
+	int to_sent = ((cur_acked_ + sndwin_) > (num_pkts_) ? (num_pkts_) : (cur_acked_ + sndwin_)) - max_snd_;
+	int num_pkt_sent = subflowSend(to_sent);		// initialization , but not useful in the first loop
+
+	if((*mptcp_pkts_)[num_pkts_-1]){
+		// if all data is sent and acked, print the current timestamp for the accomplishment of transmission
+		double ft = Scheduler::instance().clock();
+		printf("%d\t%lf\n", mptcp_id_, ft);
+	}
+	return;
+}
+
diff -ruN ns/ns-2.35/apps/mptcp.h ns-allinone-2.35/ns-2.35/apps/mptcp.h
--- ns/ns-2.35/apps/mptcp.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/apps/mptcp.h	2018-11-06 05:44:49.610310327 +0800
@@ -0,0 +1,115 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Daedalus Research
+ *	Group at the University of California Berkeley.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Contributed by the Daedalus Research Group, http://daedalus.cs.berkeley.edu
+ *
+ */
+
+#ifndef ns_mptcp_h
+#define ns_mptcp_h
+
+#include "config.h"
+#include "packet.h"
+#include "agent.h"
+#include "tcp.h"		// Jesson
+#include "ns-process.h"
+//#include <vector>
+
+/* @author Jesson LIU, for MPTCP
+ * the sending window should be the same as receiving window (in tcp/tcp-sink.h)
+ * however, since tcp/tcp-sink.h includes this tcp.h file, modifying this SUB_WND_LEN will lead to
+ * the same changing in tcp-sink.h file.
+ */
+//#define SUB_WND_LEN 10
+
+//class Agent;
+
+#define MINRTT		0
+#define ROUNDROBIN	1
+
+struct SubflowInfo{
+
+	TcpAgent *tcp_;
+	u_int8_t id;
+	int high_acked;
+	int cur_seq;
+	int cwnd;
+	double rtt;
+	short block_counter_;
+};
+
+class Mptcp : public Application {
+public:
+	Mptcp();
+	virtual void send(int nbytes);
+	virtual void recv(int nbytes);
+	virtual void resume();
+	virtual void agentCallBack(int sid, int high_acked, int cur_seq, int cwnd, double rtt);
+	virtual void notifyReceive(int pid);
+	//void reportCWND(int subflow_index, int high_acked, int cur_seq, int cwnd);
+	//void reportRTT(int subflow_index, double rtt);
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+	virtual void start();
+	virtual void stop();
+	
+	void initialPkts();		// initialize the pkt sending window queue
+	void initialSubflow();		// initialize the information of subflows
+	void updateSndWnd();		// update the sending window of MPTCP
+	void subflowSend(int idx, int len);	// the idx-th subflow sents len pkts
+	int subflowSend(int len);	// select a suitable subflow and send len pkts at maximum, the actual number of pkt sent is return by this function
+
+	Agent *agent_;
+
+	// @author Jesson LIU, beginning of mptcp attributes
+	bool isNumSubflowSet;
+	int mptcp_id_;			// the id of current MPTCP, starting from '0'
+	short max_tcp_num_;
+	short cur_tcp_;
+	int num_pkts_;
+	int last_send_;				// the id of the last subflow that sent data
+	std::vector<struct SubflowInfo*>* subinfo_;
+	int sndwin_;				// the length of MPTCP sending window
+	int length_;				// the unit of sndwin_. sndwin_ = max_tcp_num_ * length_;
+	int cur_acked_;				// current left sequence number of MPTCP sending window
+	int max_snd_;				// maximum sent sequence number of MPTCP
+	int scheduler_;				// 0: default, MinRTT first; 1: roundrobin;
+	int max_block_counter_;			// the maximum number of unchosen times in MINRTT scheduler, for preventing stavation and probing changes of network
+	std::vector<short>* mptcp_pkts_;	// the set of MPTCP packets
+
+	int enableRecv_;		// call Tcl recv or not
+	int enableResume_;		// call Tcl resume or not
+};
+
+#endif
diff -ruN ns/ns-2.35/classifier/classifier.h ns-allinone-2.35/ns-2.35/classifier/classifier.h
--- ns/ns-2.35/classifier/classifier.h	2010-03-08 13:54:49.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/classifier/classifier.h	2018-12-16 05:07:27.953177630 +0800
@@ -39,6 +39,8 @@
 
 #include "object.h"
 
+extern int PATH_ID_;
+
 class Packet;
 
 class Classifier : public NsObject {
@@ -76,6 +78,9 @@
 
 	int allocPort (NsObject *);	
 protected:
+
+	int path_id_;	//Jesson, for debug
+
 	virtual int getnxt(NsObject *);
 	virtual int command(int argc, const char*const* argv);
 	void alloc(int);
@@ -87,6 +92,7 @@
 	int mask_;
 	NsObject *default_target_;
 	int nsize_;       //what size of nslot_ should be
+	
 };
 
 #endif
diff -ruN ns/ns-2.35/classifier/classifier-mpath.cc ns-allinone-2.35/ns-2.35/classifier/classifier-mpath.cc
--- ns/ns-2.35/classifier/classifier-mpath.cc	2005-08-26 02:58:01.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/classifier/classifier-mpath.cc	2018-12-16 07:44:25.108248400 +0800
@@ -50,17 +50,50 @@
 #endif
 
 #include "classifier.h"
+#include "random.h"	// added for ECMP
+#include "ip.h"		// added for ECMP
+
+int PATH_ID_ = 0;
+
+#define MAX_PATH 3000
 
 class MultiPathForwarder : public Classifier {
 public:
-	MultiPathForwarder() : ns_(0) {} 
-	virtual int classify(Packet*) {
+	int flowPath[MAX_PATH];
+
+	MultiPathForwarder() : ns_(0) {
+
+		path_id_ = PATH_ID_++;
+
+		for(int i=0; i<MAX_PATH; i++){
+			flowPath[i] = -1;
+		}
+	
+	}
+ 
+	virtual int classify(Packet* pkt) {
 		int cl;
 		int fail = ns_;
-		do {
+
+		Random::seed_heuristically();		// @author Jesson LIU, randomlize differently every trial.
+		hdr_ip *iph = hdr_ip::access(pkt);
+
+		// original routing function, comment it
+		/*do {
 			cl = ns_++;
 			ns_ %= (maxslot_ + 1);
-		} while (slot_[cl] == 0 && ns_ != fail);
+		} while (slot_[cl] == 0 && ns_ != fail);*/
+
+		if(flowPath[iph->fid_] < 0){
+			// use random function to mimic hash function
+			cl = (int)Random::uniform(0, maxslot_+1);
+			//printf("Path %d: egress [%d] for fid:%d\n", path_id_, cl, iph->fid_);
+			flowPath[iph->fid_] = cl;
+		}else{
+			
+			cl = flowPath[iph->fid_];
+//			printf("%d-th path: cl:%d\n", path_id_, cl);
+		}
 		return cl;
 	}
 private:
diff -ruN ns/ns-2.35/common/agent.cc ns-allinone-2.35/ns-2.35/common/agent.cc
--- ns/ns-2.35/common/agent.cc	2010-03-08 13:54:49.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/common/agent.cc	2018-11-01 01:37:08.195147673 +0800
@@ -72,6 +72,8 @@
 	channel_(0), traceName_(NULL),
 	oldValueList_(NULL), app_(0), et_(0)
 {
+	// Jesson LIU
+	//mptcp_seq_ = new std::vector<struct mptcp_seq_info*>();
 }
 
 void
@@ -537,3 +539,7 @@
 
 void Agent::trace_event(char *)
 {}
+
+/*void Agent::setPara(int start, int len){
+
+}*/
diff -ruN ns/ns-2.35/common/agent.h ns-allinone-2.35/ns-2.35/common/agent.h
--- ns/ns-2.35/common/agent.h	2011-08-27 03:26:39.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/common/agent.h	2018-11-01 01:35:50.378745658 +0800
@@ -42,6 +42,9 @@
 #include "timer-handler.h"
 #include "ns-process.h"
 #include "app.h"
+
+//#include <vector>		// Jesson LIU
+
 //#include "basetrace.h"
 #define TIME_FORMAT "%.15g"
 // TIME_FORMAT is in basetrace.h, but including that header leads to problems
@@ -58,6 +61,11 @@
 
 class Application;
 
+/*struct mptcp_seq_info {
+
+	int tcp_seq;
+	int mptcp_seq;
+};*/
 
 // store old value of traced vars
 // work only for TracedVarTcl
@@ -100,6 +108,10 @@
 	virtual void listen();
 	virtual void attachApp(Application* app);
 	virtual int& size() { return size_; }
+
+	// Jesson LIU, for passing down MPTCP SEQ
+//	virtual void setPara(int start, int len);
+
 	inline nsaddr_t& addr() { return here_.addr_; }
 	inline nsaddr_t& port() { return here_.port_; }
 	inline nsaddr_t& daddr() { return dst_.addr_; }
@@ -127,6 +139,8 @@
 	int flags_;			// for experiments (see ip.h)
 	int defttl_;			// default ttl for outgoing pkts
 
+//	std::vector<struct mptcp_seq_info*>* mptcp_seq_;	// Jesson LIU
+
 #ifdef notdef
 	int seqno_;		/* current seqno */
 	int class_;		/* class to place in packet header */

diff -ruN ns/ns-2.35/Makefile.in ns-allinone-2.35/ns-2.35/Makefile.in
--- ns/ns-2.35/Makefile.in	2011-10-24 00:29:54.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/Makefile.in	2018-10-24 04:21:17.517117971 +0800
@@ -177,7 +177,7 @@
 	classifier/classifier-port.o src_rtg/classifier-sr.o \
         src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
 	qs/qsagent.o qs/hdr_qs.o \
-	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
+	apps/app.o apps/telnet.o tcp/tcplib-telnet.o apps/mptcp.o \
 	tools/trafgen.o trace/traffictrace.o tools/pareto.o \
 	tools/expoo.o tools/cbr_traffic.o \
 	adc/tbf.o adc/resv.o adc/sa.o tcp/saack.o \
diff -ruN ns/ns-2.35/mobile/god.cc ns-allinone-2.35/ns-2.35/mobile/god.cc
--- ns/ns-2.35/mobile/god.cc	2006-12-27 22:57:23.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/mobile/god.cc	2018-11-01 01:53:49.264114643 +0800
@@ -474,9 +474,9 @@
     return false;
   }
 
-  vector a(mb_node[i]->X(), mb_node[i]->Y(), mb_node[i]->Z());
-  vector b(mb_node[j]->X(), mb_node[j]->Y(), mb_node[j]->Z());
-  vector d = a - b;
+  vector_m a(mb_node[i]->X(), mb_node[i]->Y(), mb_node[i]->Z());
+  vector_m b(mb_node[j]->X(), mb_node[j]->Y(), mb_node[j]->Z());
+  vector_m d = a - b;
 
   if (d.length() < RANGE)
     return true;
diff -ruN ns/ns-2.35/mobile/god.h ns-allinone-2.35/ns-2.35/mobile/god.h
--- ns/ns-2.35/mobile/god.h	2006-02-21 23:20:19.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/mobile/god.h	2018-11-01 01:53:27.040006459 +0800
@@ -76,39 +76,39 @@
 
 // Cut and Paste from setdest.h   -- Chalermek 12/1/99
 
-class vector {
+class vector_m {
 public:
-	vector(double x = 0.0, double y = 0.0, double z = 0.0) {
+	vector_m(double x = 0.0, double y = 0.0, double z = 0.0) {
 		X = x; Y = y; Z = z;
 	}
 	double length() {
 		return sqrt(X*X + Y*Y + Z*Z);
 	}
 
-	inline void operator=(const vector a) {
+	inline void operator=(const vector_m a) {
 		X = a.X;
 		Y = a.Y;
 		Z = a.Z;
 	}
-	inline void operator+=(const vector a) {
+	inline void operator+=(const vector_m a) {
 		X += a.X;
 		Y += a.Y;
 		Z += a.Z;
 	}
-	inline int operator==(const vector a) {
+	inline int operator==(const vector_m a) {
 		return (X == a.X && Y == a.Y && Z == a.Z);
 	}
-	inline int operator!=(const vector a) {
+	inline int operator!=(const vector_m a) {
 		return (X != a.X || Y != a.Y || Z != a.Z);
 	}
-	inline vector operator-(const vector a) {
-		return vector(X-a.X, Y-a.Y, Z-a.Z);
+	inline vector_m operator-(const vector_m a) {
+		return vector_m(X-a.X, Y-a.Y, Z-a.Z);
 	}
-	friend inline vector operator*(const double a, const vector b) {
-		return vector(a*b.X, a*b.Y, a*b.Z);
+	friend inline vector_m operator*(const double a, const vector_m b) {
+		return vector_m(a*b.X, a*b.Y, a*b.Z);
 	}
-	friend inline vector operator/(const vector a, const double b) {
-		return vector(a.X/b, a.Y/b, a.Z/b);
+	friend inline vector_m operator/(const vector_m a, const double b) {
+		return vector_m(a.X/b, a.Y/b, a.Z/b);
 	}
 
 	double X;
diff -ruN ns/ns-2.35/queue/drop-tail.cc ns-allinone-2.35/ns-2.35/queue/drop-tail.cc
--- ns/ns-2.35/queue/drop-tail.cc	2004-10-29 07:35:37.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/queue/drop-tail.cc	2018-12-11 09:27:31.429811276 +0800
@@ -39,6 +39,8 @@
 
 #include "drop-tail.h"
 
+int queue_id_ = 0;		// Jesson LIU
+
 static class DropTailClass : public TclClass {
  public:
 	DropTailClass() : TclClass("Queue/DropTail") {}
@@ -88,7 +90,13 @@
                 Queue::updateStats(qib_?q_->byteLength():q_->length());
 	}
 
+	// Jesson LIU, for MPTCP queue length statistics
+	/*double now = Scheduler::instance().clock();
+	int length = q_->length();
+	printf("QDELAY: %d-th-queue %lf %d\n", id_, now, length);*/
+
 	int qlimBytes = qlim_ * mean_pktsize_;
+	
 	if ((!qib_ && (q_->length() + 1) >= qlim_) ||
   	(qib_ && (q_->byteLength() + hdr_cmn::access(p)->size()) >= qlimBytes)){
 		// if the queue would overflow if we added this packet...
@@ -130,6 +138,11 @@
         if (summarystats && &Scheduler::instance() != NULL) {
                 Queue::updateStats(qib_?q_->byteLength():q_->length());
         }
+	// Jesson LIU, for MPTCP queue length statistics
+	/*double now = Scheduler::instance().clock();
+	int length = q_->length();
+	printf("QLEN: %d-th-queue %lf %d\n", id_, now, length);*/
+
 	return q_->deque();
 }
 
diff -ruN ns/ns-2.35/queue/drop-tail.h ns-allinone-2.35/ns-2.35/queue/drop-tail.h
--- ns/ns-2.35/queue/drop-tail.h	2004-10-29 07:35:37.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/queue/drop-tail.h	2018-11-05 04:25:23.320733597 +0800
@@ -41,6 +41,8 @@
 #include "queue.h"
 #include "config.h"
 
+extern int queue_id_;		// Jesson LIU
+
 /*
  * A bounded, drop-tail queue
  */
@@ -54,6 +56,7 @@
 		bind_bool("queue_in_bytes_", &qib_);  // boolean: q in bytes?
 		bind("mean_pktsize_", &mean_pktsize_);
 		//		_RENAMED("drop-front_", "drop_front_");
+		id_ = queue_id_++;	// Jesson LIU
 	}
 	~DropTail() {
 		delete q_;
@@ -71,6 +74,7 @@
 	void print_summarystats();
 	int qib_;       	/* bool: queue measured in bytes? */
 	int mean_pktsize_;	/* configured mean packet size in bytes */
+	int id_;		// Jesson Liu
 };
 
 #endif

diff -ruN ns/ns-2.35/tcp/tcp.cc ns-allinone-2.35/ns-2.35/tcp/tcp.cc
--- ns/ns-2.35/tcp/tcp.cc	2011-06-20 12:51:46.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/tcp/tcp.cc	2019-01-12 01:47:09.855751413 +0800
@@ -76,8 +76,11 @@
 	  first_decrease_(1), fcnt_(0), nrexmit_(0), restart_bugfix_(1), 
           cong_action_(0), ecn_burst_(0), ecn_backoff_(0), ect_(0), 
           use_rtt_(0), qs_requested_(0), qs_approved_(0),
-	  qs_window_(0), qs_cwnd_(0), frto_(0)
+	  qs_window_(0), qs_cwnd_(0), frto_(0),
+		mptcp_id_(0), subflow_num_(4)		// Jesson
 {
+	// Jesson LIU
+	mptcp_seq_ = new std::vector<struct mptcp_seq_info*>();
 #ifdef TCP_DELAY_BIND_ALL
         // defined since Dec 1999.
 #else /* ! TCP_DELAY_BIND_ALL */
@@ -101,6 +104,7 @@
         bind("necnresponses_", &necnresponses_);
         bind("ncwndcuts_", &ncwndcuts_);
 	bind("ncwndcuts1_", &ncwndcuts1_);
+
 #endif /* TCP_DELAY_BIND_ALL */
 
 }
@@ -564,6 +568,7 @@
 /* This has been modified to use the tahoe code. */
 void TcpAgent::rtt_update(double tao)
 {
+
 	double now = Scheduler::instance().clock();
 	if (ts_option_)
 		t_rtt_ = int(tao /tcp_tick_ + 0.5);
@@ -604,7 +609,11 @@
 	//
 	t_rtxcur_ = (((t_rttvar_ << (rttvar_exp_ + (T_SRTT_BITS - T_RTTVAR_BITS))) +
 		t_srtt_)  >> T_SRTT_BITS ) * tcp_tick_;
-
+	
+	//printf("in rtt_update, %d-%d now-tao: %lf-%lf\n", mptcp_id_, subflow_id_, now, tao);
+	// Jesson Liu, for MPTCP's RTT
+	float ratio = 0.5;
+	this->rtt_mptcp_ = this->rtt_mptcp_*ratio+tao*(1-ratio);
 	return;
 }
 
@@ -656,6 +665,13 @@
 	tcph->ts() = Scheduler::instance().clock();
 	int is_retransmit = (seqno < maxseq_);
  
+	// Jesson, for MPTCP
+	if(seqno>0){
+		// no MPTCP_SEQ for SYN packets (seqno==0)
+		tcph->mptcp_id() = this->mptcp_id_;
+		tcph->mptcp_seq() = findSeq(seqno);
+	}
+
 	// Mark packet for diagnosis purposes if we are in Quick-Start Phase
 	if (qs_approved_) {
 		hf->qs() = 1;
@@ -801,10 +817,12 @@
  */
 void TcpAgent::sendmsg(int nbytes, const char* /*flags*/)
 {
+//	printf("%d-%d, current %d, incremental %d\n", mptcp_id_, subflow_id_, (int)curseq_, (nbytes/size_ + (nbytes%size_ ? 1 : 0)));
 	if (nbytes == -1 && curseq_ <= TCP_MAXSEQ)
 		curseq_ = TCP_MAXSEQ; 
 	else
 		curseq_ += (nbytes/size_ + (nbytes%size_ ? 1 : 0));
+//	printf("%d-%d, max_data:%d\n", mptcp_id_, subflow_id_, (int)curseq_);
 	send_much(0, 0, maxburst_);
 }
 
@@ -914,6 +932,14 @@
 {
 	send_idle_helper();
 	int win = window();
+
+	//TODO for testing
+	/*if(win>20){
+		
+		win = 20;
+		cwnd_ = win;
+	}*/
+
 	int npackets = 0;
 
 	if (!force && delsnd_timer_.status() == TIMER_PENDING)
@@ -925,6 +951,8 @@
 	if (burstsnd_timer_.status() == TIMER_PENDING)
 		return;
 	while (t_seqno_ <= highest_ack_ + win && t_seqno_ < curseq_) {
+		
+//		printf("fid:%d, send SEQ:%d, current MAXSEQ:%d\n", fid_, (int)t_seqno_, (int)curseq_);
 		if (overhead_ == 0 || force || qs_approved_) {
 			output(t_seqno_, reason);
 			npackets++;
@@ -952,6 +980,8 @@
 		if (maxburst && npackets == maxburst)
 			break;
 	}
+//	printf("fid:%d out\n", fid_);
+
 	/* call helper function */
 	send_helper(maxburst);
 }
@@ -1398,8 +1428,9 @@
 				ecn_backoff_ = 0;
 			}
 			rtt_active_ = 0;
-			if (!ts_option_)
+			if (!ts_option_){
 				rtt_update(now - rtt_ts_);
+			}
 		}
 	}
 	if (timerfix_) newtimer(pkt);
@@ -1448,6 +1479,7 @@
 }
 
 void TcpAgent::recv_newack_helper(Packet *pkt) {
+
 	//hdr_tcp *tcph = hdr_tcp::access(pkt);
 	newack(pkt);
         if (qs_window_ && highest_ack_ >= qs_window_) {
@@ -2204,3 +2236,44 @@
 			);
 	et_->trace();
 }
+
+// Jesson LIU, for passing down the MPTCP SEQ
+void TcpAgent::setPara(int start, int len){
+
+	int cur = 0;
+	if(maxseq_>0){
+		
+		cur = (int)curseq_;
+	}else{
+		cur = 1;
+//		printf("#- %d-th MPTCP's SYN is not sent yet\n", mptcp_id_);
+	}	
+
+//	printf("%d-%d: curseq_:%d\n", mptcp_id_, subflow_id_, cur);
+	
+	for(int i=0; i<len; i++){
+		struct mptcp_seq_info* temp = new struct mptcp_seq_info;
+		temp->tcp_seq = cur;
+		temp->mptcp_seq = start+i;
+//		printf("%d-%d flow: MPTCP_SEQ:%d, SEQ:%d\n", mptcp_id_, subflow_id_, start+i, cur);	
+		cur++;
+	
+		mptcp_seq_->push_back(temp);
+	}
+}
+
+int TcpAgent::findSeq(int seqno){
+
+	int len = mptcp_seq_->size();
+	int mptcp_seq = 0;
+	for(int i=0; i<len; i++){
+
+		if((*mptcp_seq_)[i]->tcp_seq==seqno){
+
+			mptcp_seq = (*mptcp_seq_)[i]->mptcp_seq;
+			break;
+		}
+	}
+
+	return mptcp_seq;
+}
diff -ruN ns/ns-2.35/tcp/tcp-fack.cc ns-allinone-2.35/ns-2.35/tcp/tcp-fack.cc
--- ns/ns-2.35/tcp/tcp-fack.cc	2005-12-28 11:57:19.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/tcp/tcp-fack.cc	2018-11-01 01:45:47.117753759 +0800
@@ -78,13 +78,13 @@
 
 	last_ack_ = tcph->seqno();
 	highest_ack_ = last_ack_;
-	fack_ = max(fack_,highest_ack_);
+	fack_ = max(int(fack_), int(highest_ack_));
 	/* 
 	 * There are conditions under which certain versions of TCP (e.g., tcp-fs)
 	 * retract maxseq_. The following line of code helps in those cases. For
 	 * versions of TCP, it is a NOP.
 */
-	maxseq_ = max(maxseq_, highest_ack_);
+	maxseq_ = max(int(maxseq_), int(highest_ack_));
 	if (t_seqno_ < last_ack_ + 1)
 		t_seqno_ = last_ack_ + 1;
 	newtimer(pkt);
diff -ruN ns/ns-2.35/tcp/tcp-fs.cc ns-allinone-2.35/ns-2.35/tcp/tcp-fs.cc
--- ns/ns-2.35/tcp/tcp-fs.cc	2000-09-01 11:04:07.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/tcp/tcp-fs.cc	2018-11-01 01:49:05.482729235 +0800
@@ -65,7 +65,7 @@
 	double now = Scheduler::instance().clock();
 	double idle_time = now - last_recv_time_;
 	double timeout = ((t_srtt_ >> 3) + t_rttvar_) * tcp_tick_ ;
-	maxseq_ = max(maxseq_, highest_ack_);
+	maxseq_ = max(int(maxseq_), int(highest_ack_));
 
 	/* 
 	 * if the connection has been idle (with no outstanding data) for long 
@@ -172,7 +172,7 @@
 	else
 		ackcount = 1;
 	newack(pkt);
-	maxseq_ = max(maxseq_, highest_ack_);
+	maxseq_ = max(int(maxseq_), int(highest_ack_));
 	if (t_exact_srtt_ != 0) {
 		delta = tao - t_exact_srtt_;
 		if (delta < 0)
@@ -208,7 +208,7 @@
 {
 	partialnewack(pkt);
 	/* Do this because we may have retracted maxseq_ */
-	maxseq_ = max(maxseq_, highest_ack_);
+	maxseq_ = max(int(maxseq_), int(highest_ack_));
 	if (fs_mode_ && fast_loss_recov_) {
 		/* 
 		 * A partial new ack implies that more than one packet has been lost
diff -ruN ns/ns-2.35/tcp/tcp.h ns-allinone-2.35/ns-2.35/tcp/tcp.h
--- ns/ns-2.35/tcp/tcp.h	2011-08-27 03:29:57.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/tcp/tcp.h	2018-11-06 05:51:46.250212982 +0800
@@ -37,9 +37,17 @@
 
 #include "agent.h"
 #include "packet.h"
-
+#include <vector>
 //class EventTrace;
 
+#define SUB_WND_LEN 10		// Jesson LIU
+
+struct mptcp_seq_info {
+
+        int tcp_seq;
+        int mptcp_seq;
+};
+
 struct hdr_tcp {
 #define NSA 3
 	double ts_;             /* time packet generated (at source) */
@@ -56,6 +64,9 @@
 	int last_rtt_;		/* more recent RTT measurement in ms, */
 				/*   for statistics only */
 
+	int mptcp_id_;		/* Jesson LIU, mptcp id */
+	int mptcp_seq_;		/* Jesson LIU, mptcp sequence number */
+
 	static int offset_;	// offset for this header
 	inline static int& offset() { return offset_; }
 	inline static hdr_tcp* access(Packet* p) {
@@ -74,6 +85,9 @@
 	int& ackno() { return (ackno_); }  
 	int& flags() { return (tcp_flags_); }
 	int& last_rtt() { return (last_rtt_); }
+	
+	int& mptcp_id() { return (mptcp_id_); }		// Jesson
+	int& mptcp_seq() { return (mptcp_seq_); }	// Jesson
 };
 
 /* these are used to mark packets as to why we xmitted them */
@@ -190,7 +204,31 @@
 	/* These two functions aid Tmix one-way TCP agents */
 	int is_closed() {return closed_;} 
 	void clr_closed() {closed_ = 0;}
+
+	// Jesson LIU, for passing down MPTCP SEQ
+        virtual void setPara(int start, int len);
+	void setMPTCPID(int id) { mptcp_id_ = id; }
+	void setSubflowID(int id){
+
+		this->fid_ = mptcp_id_*subflow_num_+id;
+		this->subflow_id_ = id;
+//		printf("fid:%d, subflow-id:%d\n", fid_, subflow_id_);
+	}
+	void setSubflowNum(int num){
+		
+		this->subflow_num_ = num;
+	}
+
 protected:
+
+	// Jesson LIU, for convey MPTCP semantic
+	int mptcp_id_;
+	int subflow_id_;		// the id of its corresponding subflow
+	int subflow_num_;		// the number of subflows
+	double rtt_mptcp_;		// rtt used by MPTCP
+	int findSeq(int);		// find MPTCP sequence number
+	std::vector<struct mptcp_seq_info*>* mptcp_seq_;	// Jesson LIU
+
 	virtual int window();
 	virtual double windowd();
 	void print_if_needed(double memb_time);
diff -ruN ns/ns-2.35/tcp/tcp-linux.cc ns-allinone-2.35/ns-2.35/tcp/tcp-linux.cc
--- ns/ns-2.35/tcp/tcp-linux.cc	2008-03-22 00:21:31.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/tcp/tcp-linux.cc	2018-11-01 01:47:20.406213431 +0800
@@ -151,7 +151,7 @@
 	if (flag&FLAG_DATA_ACKED) {
 		highest_ack_ = tcph->seqno();
 		linux_.snd_una = (highest_ack_+1)*linux_.mss_cache;
-		maxseq_ = max(maxseq_, highest_ack_);
+		maxseq_ = max(int(maxseq_), int(highest_ack_));
 		if (t_seqno_ < highest_ack_ + 1) {
 			t_seqno_ = highest_ack_ + 1;
 			linux_.snd_nxt = t_seqno_*linux_.mss_cache;
diff -ruN ns/ns-2.35/tcp/tcp-newreno.cc ns-allinone-2.35/ns-2.35/tcp/tcp-newreno.cc
--- ns/ns-2.35/tcp/tcp-newreno.cc	2009-12-31 06:06:34.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/tcp/tcp-newreno.cc	2018-11-03 06:12:07.227377443 +0800
@@ -274,6 +274,24 @@
                         send_one();
                 }
 	}
+
+	/* Jesson, for MPTCP
+	 * update the subflow information
+	 */
+	if(tcph->seqno()>0){
+		// only report for data packet received, not for SYN pkt
+//		printf("%d-th subflow's %d-th SEQ and %d-th DATA-ACK are received\n", subflow_id_, tcph->seqno(), tcph->mptcp_seq());
+//		printf("the instant and smoothed RTT for %d-th subflow are %d and %d\n", subflow_id_, (int)t_rtt_, (int)t_srtt_);
+		// maxseq_ is the maximum sequence number subflow sent so far
+		// curseq_ is the maximum sequence number application gives
+		app_->agentCallBack(subflow_id_, int(highest_ack_), int(curseq_), int(cwnd_), rtt_mptcp_);
+		/* not only confirm current SEQ of tcp, but also need to confirm current SEQ of MPTCP 
+		 * because tcph->mptcp_seq() is not always equals to findSeq(tcph->seqno());
+		 */
+		//app_->notifyReceive(findSeq(tcph->seqno()));	// MPTCP sending window only moves when Data-ACK is update, no matter what tcp SEQ is.
+		app_->notifyReceive(tcph->mptcp_seq());
+	}
+
         if (tcph->seqno() >= last_ack_)
                 // Check if ACK is valid.  Suggestion by Mark Allman.
                 valid_ack = 1;
diff -ruN ns/ns-2.35/tcp/tcp-sink.cc ns-allinone-2.35/ns-2.35/tcp/tcp-sink.cc
--- ns/ns-2.35/tcp/tcp-sink.cc	2010-04-04 04:40:15.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/tcp/tcp-sink.cc	2018-12-11 09:29:18.665586418 +0800
@@ -39,6 +39,8 @@
 #include "tcp-sink.h"
 #include "hdr_qs.h"
 
+MptcpManager* mm_ = NULL;
+
 static class TcpSinkClass : public TclClass {
 public:
 	TcpSinkClass() : TclClass("Agent/TCPSink") {}
@@ -296,6 +298,21 @@
 	ntcp->ts() = now;
 	// timestamp the packet
 
+	/* Jesson LIU, for MPTCP
+	 * update the MPTCP SEQ and add the maximum successive MPTCP SEQ & MPTCP ID into ACKs
+	 */
+	if(mm_==NULL){
+		// initialize the mptcp manager
+		mm_ = new MptcpManager();
+	}
+	if(otcp->seqno()>0){	
+		// no data transmission in SYN packet (seqno()==0)
+		int data_ack = mm_->reportRecv(otcp->mptcp_id(), otcp->mptcp_seq());
+		ntcp->mptcp_id() = otcp->mptcp_id();
+		ntcp->mptcp_seq() = data_ack;
+	}
+	// finish
+
 	if (ts_echo_bugfix_)  /* TCP/IP Illustrated, Vol. 2, pg. 870 */
 		ntcp->ts_echo() = acker_->ts_to_echo();
 	else
@@ -756,3 +773,108 @@
 	// change the size of the common header to account for the
 	// Sack strings (2 4-byte words for each element)
 }
+
+void MptcpInfo::reportRecv(int mp_seq){
+
+	/*if(mp_seq>=(last_seq_+max_buffer_)){
+
+		printf("ERROR: MP_SEQ (%d) of %d-th MPTCP is equal or larger than buffer size (max:%d)\n"
+			, mp_seq, this->mptcp_id_, last_seq_+max_buffer_);
+	}*/
+
+	/*if(mp_seq>max_seq_recv_){
+
+		max_seq_recv_ = mp_seq;
+	}*/
+
+	// Not enough buffer, enlarge it
+	if(mp_seq>=(max_buffer_-1)){
+		
+		rebufferSeq(mp_seq);
+	}
+
+	(*mptcp_seq_)[mp_seq] = 1;
+//	printf("receive MPTCP SEQ %d, current max buffer:%d\n", mp_seq, max_buffer_);
+//	printf("# %lf %d\n", Scheduler::instance().clock(), mp_seq);
+}
+
+int MptcpInfo::getCurSeq(){
+
+	for(int i=last_seq_; i<max_buffer_; i++){
+		
+		if((*mptcp_seq_)[i]){
+//			printf("current SEQ: %d, max buffer: %d\n", i, max_buffer_);
+			cur_seq_ = i;
+		}else{
+			break;
+		}
+	}
+//	printf("-----------last:%d, cur:%d\n", last_seq_, cur_seq_);
+	/* for PAPER using, for statistics */
+//	printf("SEQ: %lf %d\n", Scheduler::instance().clock(), cur_seq_);
+	if(cur_seq_ > last_seq_){
+		last_seq_ = cur_seq_;
+	}
+
+	//return (cur_seq_-1);
+	return cur_seq_;
+}
+
+void MptcpInfo::rebufferSeq(int para_seq){
+
+	while(para_seq >= (max_buffer_-1)){
+
+		int temp = max_buffer_;
+		max_buffer_ *= 2;
+		for(int i = temp; i<max_buffer_; i++){
+		
+			mptcp_seq_->push_back(0);
+		}
+	}
+	
+
+/*	if((max_seq_recv_-last_seq_) > (int)(0.2*max_buffer_)){
+
+		// move [cur_seq_, max_seq_recv_] to [0, max_seq_recv_-cur_seq_]
+		int zone = max_seq_recv_-cur_seq_;
+		for(int i=0; i<zone; i++){
+					
+			(*mptcp_seq_)[i] = (*mptcp_seq_)[cur_seq_+i];
+		}
+		int temp_loc = max_seq_recv_-cur_seq_;
+		while(temp_loc<max_buffer_){
+
+			(*mptcp_seq_)[temp_loc] = 0;
+			temp_loc++;
+		}
+
+		last_seq_ = cur_seq_;
+	}
+	//printf("last MPTCP SEQ:%d\n", last_seq_);*/
+}
+
+int MptcpManager::reportRecv(int id, int mptcp_seq){
+
+	MptcpInfo* targetMI = NULL;
+	for(int i=0; i<this->mset_->size(); i++){
+		
+		if((*mset_)[i]->getID()==id){
+		
+			targetMI = (*mset_)[i];
+			break;
+		}
+	}
+	
+	if(targetMI == NULL){
+		// a new mptcp flow, initialize it
+		targetMI = new MptcpInfo(id);
+		this->mset_->push_back(targetMI);
+	}
+	
+	targetMI->reportRecv(mptcp_seq);
+	int data_ack = targetMI->getCurSeq();
+
+//	printf("Recvr: %d-th MPTCP's Data-ACK is %d, with receiving %d-th MPTCP SEQ\n", id, data_ack, mptcp_seq);
+	
+	return data_ack;
+}
diff -ruN ns/ns-2.35/tcp/tcp-sink.h ns-allinone-2.35/ns-2.35/tcp/tcp-sink.h
--- ns/ns-2.35/tcp/tcp-sink.h	2010-04-04 04:40:15.000000000 +0800
+++ ns-allinone-2.35/ns-2.35/tcp/tcp-sink.h	2018-11-06 05:03:04.056723913 +0800
@@ -51,6 +51,58 @@
  * "window" parameter should be less than MWM/2.
  */
 
+class MptcpInfo{
+public:
+	MptcpInfo(int id){
+		
+		this->mptcp_id_ = id;
+		mptcp_seq_ = new std::vector<unsigned char>();
+		cur_seq_ = -1;
+		last_seq_ = 0;
+//		max_seq_recv_ = -1;
+		max_buffer_ = 10000;
+		for(int i=0; i<max_buffer_; i++){
+			
+			mptcp_seq_->push_back(0);	// initialization, 0 means not received yet.
+		}
+	}
+	~MptcpInfo() {
+
+		mptcp_seq_->clear();
+		delete mptcp_seq_;
+	}
+
+	int getID(){ return this->mptcp_id_; }
+	void reportRecv(int mptcp_seq);
+	int getCurSeq();
+
+protected:
+	std::vector<unsigned char>* mptcp_seq_;
+	int mptcp_id_;
+	int cur_seq_;			// the maximum successive MPTCP SEQ
+	int last_seq_;			// the cur_seq_ before rebuff
+	int max_buffer_;		// the current buffer size
+//	int max_seq_recv_;		// the maximum SEQ received
+	void rebufferSeq(int);		// extend the buffer to accommodate more packets_;
+};
+
+class MptcpManager{
+
+public:
+	MptcpManager() { mset_ = new std::vector<MptcpInfo*>(); }
+	~MptcpManager() { 
+
+		mset_->clear();
+		delete mset_; 
+	}
+	int reportRecv(int id, int mptcp_seq);	// return current maximum successive MPTCP SEQ
+
+protected:
+	std::vector<MptcpInfo*>* mset_;	// the set of MptcpInfo
+};
+
+extern MptcpManager* mm_;
+
 class TcpSink;
 class Acker {
 public:
